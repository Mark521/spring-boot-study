# 抽象类与抽象方法

## 一、抽象类

### 1、介绍

abstract：不能创建对象

### 2、abstract

#### 1、命名空间

#### 类（抽象类）： 

不能实例化

有构造器，便于子类对象实例化的全过程

#### 方法（抽象方法）：

包含抽象方法的类一定是抽象类

若子类写了父类所有的抽象方法，才能造对象，如没有全部重写，则此类必须是抽象类

#### 2、作用域

不能修饰私有方法，静态方法，final方法，final的类

### 3、设计模式

#### 1、模板方式的设计模式

### 4、注意点

不能修饰属性和构造器等结构

不能修饰私有方法，静态方法，final的方法，final的类

# 接口

### 1、介绍

不能进行多继承，提出接口，弥补单继承的缺陷

类和接口是并列的结构

### 2、如何定义

**不能定义构造器**，不可以实例化

1、JDK7以前，只能定义全局常量和抽象方法

public static final（默认就有，可以省略）

public abstract（默认就有，可以省略）

### 3、实现：implements

接口和接口之间可以多继承

### 4、接口使用体现多态性

### 5、接口实际上可以看作一种规范

**暴露规则，降低耦合，功能扩展**

### 6、接口和抽象类一同

相同：都不能实例化，都可以被继承

不同：抽象类构造器，接口不能构造，单继承，多继承，定义关键字不一样

### 7、设计模式——代理、工厂

1、代理：为其他对象提供一种代理以控制对这个对象的访问

安全代理，远程代理（RMI），延迟代理

静态代理（），动态代理（）

2、工厂模式（工厂方法，抽象工厂）：创建者和调用者分离

简单工厂，工厂方法

抽象工厂

### 8、继承父类，和实现的接口有同名属性

父类调用：super.x

接口调用：A.x

### 9、JDK8新特性

JDK8之后除了全局常量和抽象方法外，还可以定义静态方法和默认方法等

```java
1、可以定义静态方法;
只能通过接口调用
2、可以定义默认方法;
通过实现类的对象调用默认方法，可以重写， 去掉default
public default void main(){}
3、extends 和 implements 都定义了同名同参数的方法，子类在没有重写此方法的情况下调用父类的方法——》类优先原则;
4、多个接口定义了同名同参数的默认方法，子类必须重写方法;
5、调用接口中的默认方法;
Interface.super.method();
```

### 10、体会

1、接口使用也满足多态性

2、接口实际上就是定义了一种规范

3、开发中，体会面向接口编程

# 内部类

### 局部内部类（方法，代码块，构造器）

### 成员内部类（静态内部类，非静态）

#### 1、外部类的成员

调用外部类的结构（注意静态非静态）省略Person.this.eat()

static修饰

权限修饰符

#### 2、作为一个类出现；

定义属性，方法，构造器

final的修饰

abstract修饰

#### 3、实例化成员内部类

Person.Dog a = new Person.Dog()；静态内部类

Person.Bird a = p.new Birld();



#### 4、如何使用成员内部类中区分调用外部类的结构

内部类调用外部类同名属性：Person.this.name

#### 5、使用局部内部类

Integer 缓存

#### 6、注意点

在方法中的内部类中，如果想调用内部类想使用方法中的局部变量，要求磁局部变量声明为final的。

## 抽象类和接口的异同

相同；不能实例化，都可以包含抽象方法，

不同：

抽象类：有构造器，定义属性，单继承

接口：jdk7, jdk8 jdk9有私有方法：多实现






## redis整合缓存问题

### 1、缓存穿透

描述：查询永不存在的值

解决：设置null，并设置过期时间

### 2、缓存雪崩

描述：设置过期时间的Key，在同一时间过期，会造成数据库压力

解决：在原过期时间基础上，随机加上1-5分钟的缓存时间

### 3、缓存击穿

描述：如果某个key在大量请求同时进来前刚好失效，那么所有对这个key的查询都会落在数据库

解决：加锁，大量查询只让一个去查，其他等待

## 分布式锁的添加

### 1、synchronized：本地锁只能锁当前进程，只能单个服务

### 2、分布式锁

redis set nx(not exists)  如果不存在才会占坑

```java
redistemplate.opsforvalue.setIfAbsent("");
//获取锁的问题
//还需设置过期时间， 来不及删锁  可能会造成死锁问题
//需要 获取锁  和  设置过期时间是原子位

//删除锁的问题
//1、如果业务时间很长， 锁自己过期了， 可能吧别人正在持有的锁删除了
//解决： 在占锁时， 值指定为UUID , 每个人匹配是自己的锁才删除（由于网络传输 延时问题， 导致 删除问题）
//最终：lua 脚本 将 查询和删除 设置为原子性  一起操作， 不由于 传输 延时造成 删除错误的问题
```

### 3、分布式专业版（Redlock）--java Redission

```java
//1、解决了锁的自动续期| 不用担心业务执行长问题
//2、加锁的业务只要完成，就不会自动续期
```

### 4、闭锁

1、举例

房价 1班没人锁   2...  5个班没人锁大门

```java
RCountDownLatch
    trySetCount(5)//设置个数
    await()//等待闭锁完成
    countDown()//计数
```

### 5、信号量---

1、举例

停车位,可以进行分布式服务的限流

```java
RSempaphore
    acquire()//获取车位
    release()//释放车位
    tryAcquire()//尝试获取车位
```

### 6、缓存中数据的一致性问题

#### 1、更新缓存（双写）

#### 2、删除缓存（失效）

#### 3、解决方案

1、如果是用户信息，本身并发几率比较小， 不用考虑这个问题，缓存数据加上过期时间， 每个一段时间进行主动更新就行

2、如果是商品介绍、菜单等基础数据， 可以使用canal订阅binlog的方式

> canal 数据异构问题， JD首页定制化

3、缓存数据+过期时间可以解决大部分业务对于缓存的要求

4、通过加锁保证并发读写 谢谢的时候按顺序排好队，嘟嘟无所谓， 所以适合使用读写操作

#### 4、一致性解决方案

1、缓存的所有数据有过期时间， 数据过期下一次查询触发主动更新

2、读写数据， 加上分布式的读写锁



## Spring-Cache不足

1、默认不加锁，不能解决缓存击穿的问题

@Cacheable

@Cacheable

